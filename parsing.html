<!DOCTYPE html>
<html>
<head>
  <meta name="author" content="">
  <meta charset="utf-8">
  <title>Implementing parsers</title>
  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro:400,700'
        rel='stylesheet' type='text/css'>
  <link href="css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/custom.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/hk-pyg.css" rel="stylesheet" type="text/css" media="all">
  <script src="js/jquery-2.0.3.min.js" type="text/javascript"></script>
  <script src="js/bootstrap.min.js" type="text/javascript"></script>
  <script src="js/list.min.js" type="text/javascript"></script>
</head>
<body>
  <div id="topbar" style="z-index: 3">
    <div class="container">
      <div class="row">
        <ul>
          <li><div id="pkgname">Bio 0.0.0-</div></li>
          <li><a href="#">Code</a></li>
          <li><a href="#/issues">Issues</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="container" style="z-index: auto">
    <div class="row">
      <div class="col-sm-7">
      <div id="body-content">
      <h1 id="title">Implementing parsers</h1>
<p>This document is an overview of how parsers work in Bio.jl, including how to implement new parsers.</p>
<p>The parsing framework in Bio.jl is unique amongst bioinformatics libraries. Rather than hand-written parsers, we use grammar specifications that are compiled into parser code using a tool called <a href="http://www.colm.net/open-source/ragel/">ragel</a>.</p>
<p>These parsers can generally be as fast or faster than hand-written parsers while being much more explicit about the syntax of the format they parse. Ragel parses only regular languages, which means not everything can be written as a ragel parser, yet most formats can be, including many binary formats.</p>
<h1 id="installing-ragel">Installing ragel</h1>
<p>Currently Julia is not an officially supported language in ragel, but is maintained in a BioJulia fork of the project <a href="https://github.com/BioJulia/ragel">here</a>. This will change when ragel 7.0 is released, but for the time being we have to maintain our own Julia backend.</p>
<p>Installing ragel is relatively straightforward. First you must install version 0.12 of colm, which is the language that the generator backends are implemented in.</p>
<pre><code class="language-sh">wget http://www.colm.net/files/colm/colm-0.12.0.tar.gz
tar xzf colm-0.12.0.tar.gz
cd colm-0.12.0
./configure
make install</code></pre>
<p>Then ragel can be installed.</p>
<pre><code class="language-sh">git clone https://github.com/BioJulia/ragel.git
cd ragel
./autogen.sh
./configure --disable-manual
make install</code></pre>
<h1 id="running-ragel">Running ragel</h1>
<p>Ragel takes as input a <code>.rl</code> file and generates regular Julia source code in a <code>.jl</code> file. Ragel source files are a mixture of Julia code and ragel&#39;s machine specification language.</p>
<p>In Bio.jl we use a makefile to generate parsers. The following make recipe is used to generate ragel parsers, which simply runs ragel, prepending a warning to the generated file.</p>
<pre><code class="language-make">&#37;.jl: &#37;.rl
    ragel -U -G2 &#36;&lt; -o &#36;&#64;.tmp
    echo &quot;# WARNING: This file was generated from &#36;&lt; using ragel. Do not edit&#33;&quot; &gt; &#36;&#64;
    sed &#39;s/&#91;&#91;:space:&#93;&#93;*&#36;&#36;//g&#39; &#36;&#64;.tmp &gt;&gt; &#36;&#64;
    rm &#36;&#64;.tmp</code></pre>
<p>It runs ragel with the <code>-U</code> option which sets Julia as the host language, and <code>-G2</code> which intstructs it to generate a fast goto-based parser. Ragel can generate other types of parsers generally trading off speed for conciceness: <code>-G1</code> will generate a less agressively unrolled goto based parser, while <code>-T0</code>, <code>-T1</code>, <code>-F0</code>, <code>-F1</code> generate table-based parsers, which are generally less efficient, but also produce far less code. All of these should otherwise function the same. Using <code>-G2</code> parsers will produce the fastest code, but also the code with the highest upfront compilation cost.</p>
<p>An easy mistake to make when working on a parser is to make a change to the <code>.rl</code> source file, but forget to regenerate the <code>.jl</code> file. One easy way to avoid this is to use the <a href="http://entrproject.org/">entr</a> tool, which watches some files and runs a command when one changes. Running the following command in directory of some <code>.rl</code> files and a corresponding makefile will automatically keep the <code>.jl</code> files up to date until it&#39;s killed.</p>
<pre><code class="language-sh">ls *.rl | entr make</code></pre>
<h1 id="writing-parsers">Writing parsers</h1>
<p>Throughout this guide we will demonstrate how to add new parsers by implementing a parser for a very simplistic format: a 3-field BED file, in which each line contains a sequence name followed by a start and end position. There is already a more full feature BED parser in Bio, so this is purely pedagogical, but a useful starting point.</p>
<p>A BED3 file might look like this.</p>
<pre><code>chr9    68288114        68330909
chr9    68331023        68424451
chr9    68331037        68419993
chr9    68331055        68426908
chr9    68331083        68390919
chr9    68331113        68424451</code></pre>
<h2 id="writing-a-machine-specification">Writing a machine specification</h2>
<p>Though we are using a newer version of ragel, the specification language has not significantly changed, so the the <a href="http://www.colm.net/files/ragel/ragel-guide-6.9.pdf">manual for ragel-6.9</a> is the best source to learn the basics of how to write ragel parsers. It&#39;s also useful to have a basic understanding of finite state machines &#40;FSMs&#41;. The main feature of ragel, compared to other parser generator tools for regular languages, is that it allows arbitrary code to be executed on transitions in the FSM.</p>
<p>Let&#39;s start with a basic specification BED3 in ragel.</p>
<pre><code class="language-ragel">&#37;&#37;&#123;
    machine bed3;

    seqname &#61; &#91; -~&#93;*;
    start   &#61; digit&#43;;
    stop    &#61; digit&#43;;
    bed3_entry &#61; seqname &#39;\t&#39; start &#39;\t&#39; stop &#39;\n&#39;;
    main :&#61; bed3_entry*;
&#125;&#37;&#37;</code></pre>
<p>In <code>.rl</code> files, ragel annotations and code are marked with <code>&#37;&#37;</code> to separate it from the host language &#40;Julia, in our case&#41;. The first line of the specification gives a name to the FSM, the remaining lines define the language that it accepts. Each line of the specification assigns a name to some part of the overall machine, which is itself called <code>main</code>. We could write the whole thing as</p>
<pre><code class="language-ragel">&#37;&#37;&#123;
    machine bed3;
    main :&#61; &#40;&#91; -~&#93;* &#39;\t&#39; digit&#43; &#39;\t&#39; digit&#43; &#39;\t&#39;&#41;*;
&#125;&#37;&#37;</code></pre>
<p>but assigning names to parts of the machine makes things clearer and will help us later when we start defining actions for the parser.</p>
<p>The specification language will look familiar to those who have used parser generators or regular expressions in the past.  Similar to most regular expression grammars <code>&#43;</code> indicates &quot;one or more of&quot;, <code>*</code> &quot;any number of&quot;, and <code>&#91; -~&#93;</code> a range of accepted characters. In this case space through <code>~</code>, which is all printable ASCII characters and space.</p>
<h2 id="actions">Actions</h2>
<p>A distinguishing feature of ragel is the ability to execute arbitrary code on state machine transitions &#40;see Chapter 3 of the ragel manual&#41;. Ragel with generate code to parse the input, but it&#39;s up to us to decide what to do when parts of the language are matched. Here are some basic actions that print annoying messages whenever the machine starts or finishes matching a sequence name.</p>
<pre><code class="language-ragel">&#37;&#37;&#123;
    action seqname_begin &#123;
        println&#40;&quot;started matching seqname&quot;&#41;
    &#125;

    action seqname_finish &#123;
        println&#40;&quot;finished matching seqname&quot;&#41;
    &#125;

    seqname &#61; &#91; -~&#93;* &gt;seqname_begin &#37;seqname_finish;
&#125;&#37;&#37;</code></pre>
<p>Actions are named blocks of Julia code which get copied into the appropriate place by ragel. There are a number of annotations that can used to decide when they are executed, but typically just <code>&gt;</code> and <code>&#37;</code> are needed. The former causes an action to be executed when part of the state machine is transitioned into, and the latter when part is transitioned out of. Together they can be used to process input fields.</p>
<h2 id="parsing-in-parts">Parsing in parts</h2>
<p>Before we go further, we need to discuss some practical considerations. Parsing data contained in a string in one shot is made quite simple with ragel &#40;most of the examples you&#39;ll see in the manual follow this pattern&#41;. However with many formats we don&#39;t have the luxury of reading all the input into memory before parsing, since the input is simply too large. The BED3 files we wish to parse may represent short read alignments or other high-throughput data, so they could consist of hundreds of millions of lines. Instead we have to work from buffered input streams. This complicates parsing, but most of this complexity is hid in the <code>Bio.Ragel</code> module, which contains macros that generate code to handle buffer refills, and other gory details.</p>
<h2 id="defining-a-result-type">Defining a result type</h2>
<p>Parsers in Bio.jl work on mutable entry types, which allows us to perform very-efficient parsing by reusing previously allocated space. Defining a BED3 entry type is straightforward except for one catch: strings in Julia are immutable which prevents us from overwriting them when a new entry is read.</p>
<p>To overcome this restriction string fields in parsed types uses a special mutable string type called <code>StringField</code>. It works similarly to <code>UTF8String</code> in base but has no immutability guarentees.</p>
<pre><code class="language-julia">using Bio.StringFields

type BED3Entry
    seqname::StringField
    start::Int64
    stop::Int64
end</code></pre>
<p>This type needs to have two functions. A constructor with no parameters to allocate an empty entry, and a <code>copy</code> function.</p>
<pre><code class="language-julia">function BED3Entry&#40;&#41;
    return BED3Entry&#40;StringField&#40;&#41;, 1, 0&#41;
end


function copy&#40;entry::BED3Entry&#41;
    return BED3Entry&#40;copy&#40;entry.seqname&#41;, entry.start, entry.stop&#41;
end</code></pre>
<p>copy &#40;generic function with 1 method&#41;</p>
<h2 id="capturing-input-with-basemarkdowncodeanchor">Capturing input with Base.Markdown.Code("","@anchor!")</h2>
<p>To efficiently parse on buffered stream, <code>Bio.Ragel</code> has some tricks to avoid making unecessary allocations or copies. These revolve around &quot;anchoring&quot; the start of regions in the input that need to be processed using the <code>Ragel.&#64;anchor&#33;</code> macro. Using <code>&#64;anchor&#33;</code> saves the current position and informs the input stream not to evict that part of the input from the input buffer. If the buffer needs to be refilled, it is shifted over but saved.</p>
<p>Let&#39;s see how that works by defining a slightly more meaningful action <code>seqname</code>.</p>
<pre><code class="language-ragel">&#37;&#37;&#123;
    action anchor &#123;
        Ragel.&#64;anchor
    &#125;

    action seqname &#123;
        Ragel.&#64;copy_from_anchor&#33;&#40;output.seqname&#41;
    &#125;

    seqname &#61; &#91; -~&#93;* &gt;anchor &#37;seqname;
&#125;&#37;&#37;</code></pre>
<p>When we enter FSM state associated with <code>seqname</code>, the <code>anchor</code> action gets executed, internally marking the input stream and guaranteeing that it will stay in the buffer. We then use another macro <code>Ragel.&#64;acopy_from_anchor&#33;</code> which extracts a string directly from the input, replacing the contents of a <code>StringField</code>, and unsets the anchor, so that the data is no longer preserved.</p>
<p>There are some other handy macros for efficiently processing marked data: <code>Ragel.&#64;int64_from_anchor&#33;</code> will parse an integer from a marked region without making an intermediate copy, <code>Ragel.&#64;upanchor&#33;</code> will unset the anchor and return it&#39;s position in the input buffer. The matched region of the input buffer can extracted as an <code>UInt8</code> vector like.</p>
<pre><code class="language-ragel">state.stream.buffer&#91;&#40;Ragel.&#64;upanchor&#33;&#41;:p&#93;</code></pre>
<p>Using <code>&#64;anchor&#33;</code> has some limitations. Because it causes data to preserved and shifted on buffer refills, it can be slow if the data that it needs to preserved is very large. It efficient assuming the buffer is significantly larger than the fields being caputured so that shifts are rare. If a very long field needs to be captured, another mechanism should be used, like copying the input one character at a time to a buffer.</p>
<p>With this understood, we can complete our machine definition</p>
<pre><code class="language-ragel">&#37;&#37;&#123;
    machine bed3;

    action anchor &#123;
        Ragel.&#64;anchor&#33;
    &#125;

    action finish_match &#123;
        # calling anchor is necessary here because fbreak will skip the entry
        # action for the next state &#40;seqname, in this case&#41;
        Ragel.&#64;anchor&#33;
        yield &#61; true;
        fbreak;
    &#125;

    action seqname &#123;
        Ragel.&#64;copy_from_anchor&#33;&#40;output.seqname&#41;
    &#125;

    action start &#123;
        # convert from 0-based to 1-based
        output.start &#61; 1 &#43; Ragel.&#64;int64_from_anchor&#33;
    &#125;

    action stop &#123;
        output.stop &#61; Ragel.&#64;int64_from_anchor&#33;
    &#125;

    seqname &#61; &#91; -~&#93;*   &gt;anchor   &#37;seqname;
    start   &#61; digit&#43;   &gt;anchor   &#37;start;
    stop    &#61; digit&#43;   &gt;anchor   &#37;stop;
    bed3_entry &#61; seqname &#39;\t&#39; start &#39;\t&#39; stop &#39;\n&#39;;
    main :&#61; &#40;bed3_entry &#37;finish_match&#41;*;
&#125;&#37;&#37;</code></pre>
<h2 id="supporting-code">Supporting code</h2>
<p>Now that we have a machine definition and a entry type, we must define a parser type and write a few supportinf functions.</p>
<p>First, code generated by ragel needs to reference some special constants representing parser states. To define these we use the <code>write data</code> ragel directive.</p>
<pre><code class="language-ragel">&#37;&#37; write data;</code></pre>
<p>Since most formats are read entry-by-entry, we need a type to keep track of the parser state between calls. This type must have a field called <code>state</code> of type <code>Ragel.State</code>. It can contain any other supporting data useful for parsing, such as intermediate results.</p>
<pre><code class="language-julia">using Bio: AbstractParser
import Bio.Ragel

type BED3Parser &lt;: AbstractParser
    state::Ragel.State
end</code></pre>
<p>There are three functions we must define for the parser to be functional: <code>eltype</code>, <code>open</code>, and <code>read&#33;</code>. The first two have obvious definitions.</p>
<pre><code class="language-julia"># return the type that BED3Parser reads to
function eltype&#40;::Type&#123;BED3Parser&#125;&#41;
    return BED3Entry
end</code></pre>
<p>eltype &#40;generic function with 1 method&#41;</p>
<p>Secondly, we need an <code>open</code> function. To do this, we define an empty file format type used to indicate BED3.</p>
<pre><code>immutable BED3 &lt;: FileFormat end

function open&#40;input::BufferedInputStream, ::Type&#123;BED3&#125;&#41;
    return BED3Parser&#40;input&#41;
end</code></pre>
<p><code>open</code> needs only be defined over a <code>BufferedInputStream</code> to work for file names and byte vectors automatically.</p>
<p>Lastly the <code>read&#33;</code> function, which to simplify we generate using a macro: <code>Ragel.&#64;generate_read_function</code>. This takes four parameters: a string giving the ragel machine name, the parser type, the entry type, and finally ragel generated state machine code. Putting this together, defining our <code>read&#33;</code> function looks like:</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">Ragel.&#64;generate_read_fuction&#40;&quot;bed3&quot;, BED3Parser, BED3Entry,
    begin
        &#37;&#37; write exec;
    end&#41;</code></pre>
<p>Our parser is ready to use now.</p>
<h1 id="optimizing-and-debugging-parsers">Optimizing and debugging parsers</h1>
<p>A major complication is debugging or optimizing ragel generated parsers is that with current versions of Julia, line numbers in stack traces and profiler output will be unreliable. Until this situation improves, profiling parsers using <code>&#64;profile</code> is of limited use. A more fruitful way to improve the speed of parsers is to work from the state transition diagram.</p>
<p>These diagrams can often illucidate unecessary work being performed by the parser, or incorrectly specified grammars. Tracing through this diagram step-by-step, and making sure it agrees with your intention is an important sanity check when implementing a moderately complex parser.</p>
<p>Unfortunately, there are some issues with generating these state diagrams with our development version of ragel. To produce these you should install the <a href="http://www.colm.net/files/ragel/ragel-6.9.tar.gz">ragel 6.9</a> in a separate directory. You will also need <a href="http://www.graphviz.org/">graphviz</a>.</p>
<p>The makefile rules we use to generate diagrams are</p>
<pre><code class="language-make">&#37;.dot: &#37;.rl
    ~/src/ragel-6.9/ragel/ragel -p -V &#36;&lt; &gt; &#36;&#64;

&#37;.svg: &#37;.dot
    dot -Tsvg &lt; &#36;&lt; &gt; &#36;&#64;</code></pre>
<p>This assumes ragel 6.9 is compiled in <code>~/src/ragel-6.9/</code>. It first runs ragel to generate <code>.dot</code> graphviz specification file, then runs the graphviz <code>dot</code> program to generate an svg file.</p>

      <hr>
      </div>
      </div>

      <div class="col-sm-offset-8" style="z-index: 2">
        <div id="table-of-contents">
          <div id="table-of-contents-content">
            <input class="search" placeholder="SEARCH" />
            <ul class="toc list nav"><li>
    <a class="toc-item" href="index.html">Introduction</a>
</li>
<li>
    <a class="toc-item" href="reading.html">Reading and writing data</a>
</li>
<li>
    <hr><div class="toc-part">Seq</div>
</li>
<li>
    <a class="toc-item" href="seq.html">Nucleotide and amino acid sequences</a>
</li>
<li>
    <hr><div class="toc-part">Intervals</div>
</li>
<li>
    <a class="toc-item" href="intervals.html">Genomic interval manipulation</a>
</li>
<li>
    <hr><div class="toc-part">Contributing</div>
</li>
<li>
    <a class="toc-item toc-current-doc" href="parsing.html">Implementing parsers</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#installing-ragel">Installing ragel</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#running-ragel">Running ragel</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#writing-parsers">Writing parsers</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#writing-a-machine-specification">Writing a machine specification</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#actions">Actions</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#parsing-in-parts">Parsing in parts</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#defining-a-result-type">Defining a result type</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#capturing-input-with-">Capturing input with </a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#supporting-code">Supporting code</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#optimizing-and-debugging-parsers">Optimizing and debugging parsers</a>
</li>
</ul>

            <script>
                var toclist = new List("table-of-contents",
                                       {valueNames: ["toc-item"]})

                $("body").scrollspy({target: "#table-of-contents"});

                $("#table-of-contents li").on("activate.bs.scrollspy",
                    function(event) {
                        $("#table-of-contents ul").find("a").css({"font-weight": "normal"});
                        $(this).children("a").css({"font-weight": "bolder"});
                    });
            </script>
          </div>
        </div>
      </div>
    </div>

  <footer class="col-sm-8">
    <p class="muted">Last modified by  on . Generated with
    <a href="https://github.com/dcjones/Judo.jl">Judo</a>.</p>
  </footer>

  </div>
</body>
</html>

